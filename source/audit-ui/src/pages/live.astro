---
import Layout from '../layouts/Layout.astro';
---

<Layout title="Live Traffic - Bitsmedia Audit">
	<div class="live-page">
		<h1>Live Traffic Monitoring</h1>
		
		<div class="status-bar">
			<div class="status-indicator">
				<span class="status-dot" id="status-dot"></span>
				<span id="connection-status">Connecting...</span>
			</div>
			<div class="stats-inline">
				<span>Events: <strong id="event-counter">0</strong></span>
				<span>|</span>
				<span>Rate: <strong id="event-rate">0/min</strong></span>
			</div>
		</div>
		
		<div class="chart-card">
			<h2>Top 5 Security Rules (Last 15 Minutes)</h2>
			<div id="chart-container"></div>
		</div>
		
		<div class="events-card">
			<div class="events-header">
				<h2>Live Event Stream</h2>
				<button id="pause-btn" class="btn-secondary">Pause</button>
			</div>
			<div class="table-container">
				<table id="events-table">
					<thead>
						<tr>
							<th>Time</th>
							<th>Source IP</th>
							<th>Rule</th>
							<th>Severity</th>
							<th>Action</th>
							<th>Latency</th>
							<th>Country</th>
						</tr>
					</thead>
					<tbody id="events-tbody">
						<tr>
							<td colspan="7" class="loading">Waiting for events...</td>
						</tr>
					</tbody>
				</table>
			</div>
		</div>
	</div>
</Layout>

<style>
	.live-page {
		max-width: 1400px;
		margin: 0 auto;
	}
	h1 {
		color: #1a1a2e;
		margin-bottom: 1.5rem;
		font-size: 2.5rem;
	}
	.status-bar {
		background: white;
		padding: 1rem 2rem;
		border-radius: 8px;
		box-shadow: 0 2px 8px rgba(0,0,0,0.1);
		margin-bottom: 2rem;
		display: flex;
		justify-content: space-between;
		align-items: center;
	}
	.status-indicator {
		display: flex;
		align-items: center;
		gap: 0.75rem;
	}
	.status-dot {
		width: 12px;
		height: 12px;
		border-radius: 50%;
		background: #95a5a6;
		animation: pulse 2s infinite;
	}
	.status-dot.connected {
		background: #2ecc71;
	}
	.status-dot.disconnected {
		background: #e74c3c;
		animation: none;
	}
	@keyframes pulse {
		0%, 100% { opacity: 1; }
		50% { opacity: 0.5; }
	}
	.stats-inline {
		display: flex;
		gap: 1rem;
		color: #666;
	}
	.stats-inline strong {
		color: #1a1a2e;
	}
	.chart-card {
		background: white;
		padding: 2rem;
		border-radius: 8px;
		box-shadow: 0 2px 8px rgba(0,0,0,0.1);
		margin-bottom: 2rem;
	}
	.chart-card h2 {
		color: #1a1a2e;
		margin-bottom: 1.5rem;
		font-size: 1.25rem;
	}
	#chart-container {
		min-height: 300px;
		display: flex;
		align-items: center;
		justify-content: center;
	}
	.events-card {
		background: white;
		border-radius: 8px;
		box-shadow: 0 2px 8px rgba(0,0,0,0.1);
		overflow: hidden;
	}
	.events-header {
		padding: 1.5rem 2rem;
		border-bottom: 1px solid #e0e0e0;
		display: flex;
		justify-content: space-between;
		align-items: center;
	}
	.events-header h2 {
		color: #1a1a2e;
		font-size: 1.25rem;
	}
	.btn-secondary {
		padding: 0.5rem 1rem;
		background: #e0e0e0;
		border: none;
		border-radius: 6px;
		cursor: pointer;
		font-size: 0.9rem;
	}
	.btn-secondary:hover {
		background: #d0d0d0;
	}
	.table-container {
		overflow-x: auto;
		max-height: 600px;
	}
	table {
		width: 100%;
		border-collapse: collapse;
	}
	th {
		background: #f5f5f5;
		padding: 1rem;
		text-align: left;
		font-size: 0.85rem;
		font-weight: 600;
		color: #666;
		text-transform: uppercase;
		position: sticky;
		top: 0;
		z-index: 10;
	}
	td {
		padding: 0.75rem 1rem;
		border-bottom: 1px solid #f0f0f0;
		color: #333;
		font-size: 0.9rem;
	}
	td.loading {
		text-align: center;
		color: #999;
		padding: 2rem;
	}
	tr.new-event {
		animation: highlight 1s ease-in-out;
	}
	@keyframes highlight {
		0% { background: #d1f2eb; }
		100% { background: white; }
	}
	.severity-badge {
		display: inline-block;
		padding: 0.25rem 0.75rem;
		border-radius: 12px;
		font-size: 0.75rem;
		font-weight: 600;
	}
	.severity-low { background: #d5f4e6; color: #0a6e5c; }
	.severity-medium { background: #fff3cd; color: #856404; }
	.severity-high { background: #f8d7da; color: #721c24; }
	.severity-critical { background: #f5c6cb; color: #491217; }
	.action-allowed { color: #27ae60; }
	.action-blocked { color: #e74c3c; font-weight: 600; }
</style>

<script>
	import { isAuthenticated, getToken } from '../utils/auth';
	import { createWSClient, type WSEvent } from '../utils/websocket';
	import { api } from '../utils/api';
	import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Cell } from 'recharts';
	import { createElement } from 'react';
	import { createRoot } from 'react-dom/client';

	// Check authentication
	if (!isAuthenticated()) {
		window.location.href = '/login';
	}

	let ws: WebSocket | null = null;
	let isPaused = false;
	const events: any[] = [];
	const MAX_EVENTS = 100;
	let eventCount = 0;
	let eventTimestamps: number[] = [];
	let chartRoot: any = null;

	// Initialize chart
	function initChart() {
		const container = document.getElementById('chart-container');
		if (container && !chartRoot) {
			chartRoot = createRoot(container);
			updateChart([]);
		}
	}

	// Update chart
	function updateChart(data: any[]) {
		if (!chartRoot) return;
		
		const colors = ['#4ecca3', '#45b393', '#3d9d84', '#358775', '#2d7266'];
		
		const ChartComponent = createElement(ResponsiveContainer, { width: '100%', height: 300 },
			createElement(BarChart, { data },
				createElement(CartesianGrid, { strokeDasharray: '3 3' }),
				createElement(XAxis, { dataKey: 'name', angle: -15, textAnchor: 'end', height: 100 }),
				createElement(YAxis, null),
				createElement(Tooltip, null),
				createElement(Bar, { dataKey: 'count', fill: '#4ecca3' },
					data.map((_: any, index: number) => 
						createElement(Cell, { key: `cell-${index}`, fill: colors[index % colors.length] })
					)
				)
			)
		);
		
		chartRoot.render(ChartComponent);
	}

	// Load rule stats
	async function loadRuleStats() {
		try {
			const response = await api.get('/events/stats/rules?window=15m');
			// Extract from structured response
			const apiData = response.data.data || {};
			const rules = apiData.rules || [];
			
			const chartData = rules.map((rule: any) => ({
				name: rule.rule_name.length > 25 ? rule.rule_name.substring(0, 25) + '...' : rule.rule_name,
				count: rule.count
			}));
			
			updateChart(chartData);
		} catch (error) {
			console.error('Failed to load rule stats:', error);
		}
	}

	// Connect to WebSocket
	function connectWebSocket() {
		const token = getToken();
		if (!token) return;
		
		const statusDot = document.getElementById('status-dot');
		const statusText = document.getElementById('connection-status');
		
		try {
			ws = createWSClient(token);
			
			ws.onopen = () => {
				console.log('WebSocket connected');
				if (statusDot) statusDot.classList.add('connected');
				if (statusText) statusText.textContent = 'Connected';
			};
			
			ws.onmessage = (event) => {
				const message: WSEvent = JSON.parse(event.data);
				
				if (message.type === 'event' && !isPaused) {
					handleNewEvent(message.data);
				}
			};
			
			ws.onerror = (error) => {
				console.error('WebSocket error:', error);
				if (statusDot) statusDot.classList.add('disconnected');
				if (statusText) statusText.textContent = 'Error';
			};
			
			ws.onclose = () => {
				console.log('WebSocket disconnected');
				if (statusDot) {
					statusDot.classList.remove('connected');
					statusDot.classList.add('disconnected');
				}
				if (statusText) statusText.textContent = 'Disconnected';
				
				// Reconnect after 5 seconds
				setTimeout(connectWebSocket, 5000);
			};
		} catch (error) {
			console.error('Failed to connect WebSocket:', error);
		}
	}

	// Handle new event
	function handleNewEvent(event: any) {
		events.unshift(event);
		if (events.length > MAX_EVENTS) events.pop();
		
		eventCount++;
		const counterEl = document.getElementById('event-counter');
		if (counterEl) counterEl.textContent = eventCount.toString();
		
		// Track for rate calculation
		eventTimestamps.push(Date.now());
		eventTimestamps = eventTimestamps.filter(t => Date.now() - t < 60000);
		const rateEl = document.getElementById('event-rate');
		if (rateEl) rateEl.textContent = `${eventTimestamps.length}/min`;
		
		renderEvents();
	}

	// Render events table
	function renderEvents() {
		const tbody = document.getElementById('events-tbody');
		if (!tbody) return;
		
		if (events.length === 0) {
			tbody.innerHTML = '<tr><td colspan="7" class="loading">Waiting for events...</td></tr>';
			return;
		}
		
		tbody.innerHTML = events.map((event, index) => `
			<tr class="${index === 0 ? 'new-event' : ''}">
				<td>${new Date(event.ts).toLocaleTimeString()}</td>
				<td>${event.source_ip}</td>
				<td>${event.rule_name}</td>
				<td>
					<span class="severity-badge severity-${event.severity}">
						${event.severity.toUpperCase()}
					</span>
				</td>
				<td class="action-${event.action}">${event.action.toUpperCase()}</td>
				<td>${event.latency_ms}ms</td>
				<td>${event.country}</td>
			</tr>
		`).join('');
	}

	// Pause/Resume
	const pauseBtn = document.getElementById('pause-btn');
	pauseBtn?.addEventListener('click', () => {
		isPaused = !isPaused;
		if (pauseBtn) pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
	});

	// Initialize
	initChart();
	connectWebSocket();
	loadRuleStats();
	
	// Refresh stats every 3 seconds
	setInterval(loadRuleStats, 3000);
	
	// Cleanup on page unload
	window.addEventListener('beforeunload', () => {
		if (ws) ws.close();
	});
</script>

